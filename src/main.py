"""
Algoritmo Gen√©tico OTIMIZADO para resolver o Desafio de Einstein
Disciplina: Intelig√™ncia Artificial
Prof. Tiago Bonini Borchartt

VERS√ÉO OTIMIZADA COM ESTRAT√âGIAS AVAN√áADAS
"""

import time
import random
import copy

from genetic_algorithm import (
    random_chrom,
    mutate,
    crossover,
    hybrid_selection,
    tournament_selection,
    smart_mutate,
    directed_mutate,
    local_search,
    advanced_crossover,
    create_elite_offspring,
    specialized_rule5_mutate,
    debug_rule5_status,
    intensive_rule5_repair,
    brute_force_rule5,
    analyze_chromosome_detailed,
    debug_specific_rule,
    print_chromosome_visual,
    deep_population_analysis,
    show_solution,
    controlled_rule5_fix,
    emergency_rule5_solver,
    ultra_debug_mutation_failure,
    analyze_population_stagnation,
    diversity_explosion,
    force_rule_specific_variations,
)
from einstein_rules import (
    fitness,
    weighted_fitness,
    get_missing_rules,
    detailed_fitness_report,
    partial_fitness_scores,
)

# Par√¢metros otimizados dinamicamente
BASE_POPULATION_SIZE = 3000
MAX_POPULATION_SIZE = 5000
BASE_CROSSOVER_RATE = 0.90
BASE_MUTATION_RATE = 0.15
SURVIVAL_RATE = 0.10
IMMIGRATION_RATE = 0.15


class AdvancedGeneticAlgorithm:
    def __init__(self):
        self.population_size = BASE_POPULATION_SIZE
        self.crossover_rate = BASE_CROSSOVER_RATE
        self.mutation_rate = BASE_MUTATION_RATE

        # Controle adaptativo
        self.generations_without_improvement = 0
        self.current_best_fitness = 0
        self.generations_at_14 = 0
        self.generations_at_13 = 0

        # Estat√≠sticas
        self.fitness_history = []
        self.diversity_history = []

    def adapt_parameters(self, best_fitness, diversity):
        """Adapta par√¢metros baseado no progresso atual"""

        if best_fitness >= 14:
            # MODO SPRINT FINAL - m√°xima intensidade
            self.population_size = min(MAX_POPULATION_SIZE, self.population_size + 100)
            self.mutation_rate = 0.4  # 40% - explora√ß√£o m√°xima
            self.crossover_rate = 0.95

        elif best_fitness >= 13:
            # MODO CONVERG√äNCIA FOCADA
            self.population_size = min(4000, self.population_size + 50)
            self.mutation_rate = 0.25  # 25%
            self.crossover_rate = 0.90

        elif best_fitness >= 11:
            # MODO EXPLORA√á√ÉO MODERADA
            self.mutation_rate = 0.20
            self.crossover_rate = 0.85

        else:
            # MODO EXPLORA√á√ÉO AMPLA
            self.mutation_rate = 0.15
            self.crossover_rate = 0.80

        # Ajuste baseado na diversidade
        if diversity < self.population_size * 0.3:  # Baixa diversidade
            self.mutation_rate *= 1.5

    def create_specialized_population(self, size):
        """Cria popula√ß√£o com diferentes estrat√©gias"""
        population = []

        # 70% popula√ß√£o aleat√≥ria
        random_count = int(size * 0.7)
        population.extend([random_chrom() for _ in range(random_count)])

        # 20% popula√ß√£o com regras fixas satisfeitas
        fixed_count = int(size * 0.2)
        for _ in range(fixed_count):
            chrom = random_chrom()
            # For√ßa algumas regras f√°ceis
            # Regra 1: Noruegu√™s na primeira casa
            houses = [list(house) for house in chrom]
            for i, house in enumerate(houses):
                if house[1] == "Noruegu√™s":
                    houses[0][1], houses[i][1] = houses[i][1], houses[0][1]
                    break

            # Regra 9: Leite na casa do meio
            houses[2][2] = "Leite"

            chrom = [tuple(house) for house in houses]
            population.append(chrom)

        # 10% popula√ß√£o restante aleat√≥ria
        remaining = size - len(population)
        population.extend([random_chrom() for _ in range(remaining)])

        return population

    def run(self):
        """Executa o algoritmo gen√©tico otimizado"""
        print("üß¨ ALGORITMO GEN√âTICO OTIMIZADO - DESAFIO DE EINSTEIN")
        print("=" * 80)
        print("üéØ OBJETIVO: Encontrar solu√ß√£o 15/15")
        print("üöÄ ESTRAT√âGIAS: Busca Local + Sele√ß√£o H√≠brida + Muta√ß√£o Dirigida")
        print("üîÑ LIMITE: 500 gera√ß√µes para debug")
        print("=" * 80)

        start_time = time.time()
        MAX_GENERATIONS = 500  # LIMITE PARA DEBUG

        # Popula√ß√£o inicial especializada
        POP = self.create_specialized_population(self.population_size)

        generation = 0
        best_ever_fitness = 0
        best_ever_chromosome = None
        time_at_14 = None

        print("üìà EVOLU√á√ÉO DETALHADA:")
        print(
            "   Gera√ß√£o | Fitness | Pop.Size | Div% | Tempo(s) | Status & Estrat√©gias"
        )
        print("-" * 85)

        while True:
            generation += 1

            # CRIT√âRIO DE PARADA - LIMITE DE GERA√á√ïES PARA DEBUG
            if generation > MAX_GENERATIONS:
                elapsed = time.time() - start_time
                print(f"\n‚è∞ LIMITE DE GERA√á√ïES ATINGIDO: {MAX_GENERATIONS}")
                print(f"   üèÜ Melhor fitness: {best_ever_fitness}/15")
                print(f"   ‚è±Ô∏è Tempo total: {elapsed:.1f}s")
                print(f"   üìä M√©dia: {elapsed/generation:.3f}s por gera√ß√£o")

                if best_ever_fitness == 14:
                    missing = get_missing_rules(best_ever_chromosome)
                    print(f"   üéØ Faltou apenas: Regra {missing[0]}")
                    print_chromosome_visual(best_ever_chromosome)

                return best_ever_chromosome, best_ever_fitness

            # 1. AVALIA√á√ÉO COMPLETA
            fitness_values = [fitness(chrom) for chrom in POP]

            # Ordenar por fitness
            sorted_indices = sorted(
                range(len(POP)), key=lambda i: fitness_values[i], reverse=True
            )
            POP = [POP[i] for i in sorted_indices]
            fitness_values = [fitness_values[i] for i in sorted_indices]

            best_chrom = POP[0]
            best_fitness = fitness_values[0]
            avg_fitness = sum(fitness_values) / len(fitness_values)
            diversity = len(set(str(chrom) for chrom in POP))
            diversity_percent = (diversity / len(POP)) * 100
            elapsed = time.time() - start_time

            # Atualizar estat√≠sticas
            self.fitness_history.append(best_fitness)
            self.diversity_history.append(diversity_percent)

            # Controle de progresso
            if best_fitness > best_ever_fitness:
                best_ever_fitness = best_fitness
                best_ever_chromosome = copy.deepcopy(best_chrom)
                self.generations_without_improvement = 0

                if best_fitness == 14 and time_at_14 is None:
                    time_at_14 = elapsed
                    self.generations_at_14 = 0
            else:
                self.generations_without_improvement += 1

            if best_fitness == 13:
                self.generations_at_13 += 1
            elif best_fitness == 14:
                self.generations_at_14 += 1

            self.adapt_parameters(best_fitness, diversity)

            # LOG DETALHADO
            should_log = (
                generation % 25 == 0
                or generation < 50
                or best_fitness >= 13
                or self.generations_without_improvement % 200 == 0
            )

            if should_log:
                print(
                    f"   {generation:7d} | {best_fitness:2d}/15   | {len(POP):6d} | {diversity_percent:3.0f}% | {elapsed:6.1f}s | ",
                    end="",
                )

                # Status detalhado com estrat√©gias ativas
                if best_fitness == 15:
                    print("üéâ SOLU√á√ÉO PERFEITA ENCONTRADA!")
                elif best_fitness == 14:
                    missing = get_missing_rules(best_chrom)

                    # DEBUG MEGA DETALHADO
                    if (
                        generation % 10 == 0 or self.generations_at_14 == 1
                    ):  # A cada 10 gera√ß√µes ou primeira vez no 14
                        missing_rule = missing[0]
                        rule_debug = debug_specific_rule(best_chrom, missing_rule)

                        print(
                            f"üî• R{missing_rule} TRAVADO: {rule_debug['description']}"
                        )
                        print(f"    üîç Debug: {rule_debug['detailed_analysis']}")

                        # Se ficar muito tempo preso, faz an√°lise completa
                        if (
                            self.generations_at_14 % 50 == 0
                            and self.generations_at_14 > 0
                        ):
                            print(
                                f"\n‚ö†Ô∏è  AN√ÅLISE COMPLETA - PRESO EM R{missing_rule} h√° {self.generations_at_14} gera√ß√µes!"
                            )
                            deep_population_analysis(POP[:10], fitness, 3)
                    else:
                        missing_rule = missing[0]
                        print(
                            f"üî• R{missing_rule} PRESO h√° {self.generations_at_14} gens | Mut:{self.mutation_rate*100:.0f}% | Pop:{len(POP)}"
                        )

                elif best_fitness == 13:
                    missing = get_missing_rules(best_chrom)
                    print(
                        f"üéØ Foco 13‚Üí14! Faltam: {missing} (h√° {self.generations_at_13} gens)"
                    )
                elif best_fitness >= 11:
                    trend = "‚ÜóÔ∏è" if self.generations_without_improvement < 100 else "‚ÜîÔ∏è"
                    print(f"üìà Evolu√ß√£o {trend} | Mut:{self.mutation_rate*100:.0f}%")
                else:
                    print(
                        f"üå± Explora√ß√£o | Mut:{self.mutation_rate*100:.0f}% | Avg:{avg_fitness:.1f}"
                    )

            # 2. CRIT√âRIO DE PARADA - SOLU√á√ÉO ENCONTRADA!
            if best_fitness == 15:
                print()
                print("üéâ" * 25)
                print("                SOLU√á√ÉO 15/15 ENCONTRADA!")
                print("üéâ" * 25)
                break

            # 3. ESTRAT√âGIAS DE DIVERSIFICA√á√ÉO
            if self.generations_without_improvement > 1000:
                if best_fitness >= 14:
                    # Para fitness 14, diversifica√ß√£o suave
                    elite_size = int(len(POP) * 0.15)  # 15% elite
                    print(
                        f"   {generation:7d} | {best_fitness:2d}/15   | {len(POP):6d} | {diversity_percent:3.0f}% | {elapsed:6.1f}s | üîÑ Diversif. Suave (15% elite)"
                    )
                else:
                    # Para fitness menor, diversifica√ß√£o mais agressiva
                    elite_size = int(len(POP) * 0.08)  # 8% elite
                    print(
                        f"   {generation:7d} | {best_fitness:2d}/15   | {len(POP):6d} | {diversity_percent:3.0f}% | {elapsed:6.1f}s | üîÑ Diversif. Agressiva (8% elite)"
                    )

                POP = POP[:elite_size] + self.create_specialized_population(
                    len(POP) - elite_size
                )
                self.generations_without_improvement = 0
                continue

            # 4. OPERA√á√ïES GEN√âTICAS AVAN√áADAS

            # Elite (sobreviv√™ncia)
            num_survivors = int(len(POP) * SURVIVAL_RATE)
            survivors = POP[:num_survivors]

            # ESTRAT√âGIA ESPECIAL PARA QUALQUER REGRA NO 14/15
            if best_fitness == 14:
                missing_rule_num = (
                    get_missing_rules(best_chrom)[0]
                    if get_missing_rules(best_chrom)
                    else None
                )

                if missing_rule_num:
                    # Log detalhado a cada 20 gera√ß√µes
                    if generation % 20 == 0:
                        print(f"\nüéØ FOCO NA REGRA {missing_rule_num}:")
                        rule_debug = debug_specific_rule(best_chrom, missing_rule_num)
                        print(f"   üìã {rule_debug['description']}")
                        print(f"   üîç {rule_debug['detailed_analysis']}")
                        print_chromosome_visual(best_chrom)

                    # DEBUG SUPER DETALHADO - POPULA√á√ÉO E DIVERSIDADE
                    if generation % 50 == 0:  # A cada 50 gera√ß√µes em vez de 25
                        print(f"\nüî¨ DEBUG SUPER DETALHADO - GERA√á√ÉO {generation}")
                        print(f"   üìä Popula√ß√£o: {len(POP)} indiv√≠duos")
                        print(
                            f"   üéØ Diversidade: {diversity}/{len(POP)} = {diversity_percent:.1f}%"
                        )
                        print(
                            f"   üèÜ Fitness 14: {sum(1 for f in fitness_values if f == 14)} indiv√≠duos"
                        )
                        print(
                            f"   üìà Fitness 13: {sum(1 for f in fitness_values if f == 13)} indiv√≠duos"
                        )
                        print(
                            f"   üìâ Fitness <13: {sum(1 for f in fitness_values if f < 13)} indiv√≠duos"
                        )

                        # Analisa se existem diferentes configura√ß√µes ou todas s√£o iguais
                        solutions_14 = [chrom for chrom in POP if fitness(chrom) == 14]
                        if solutions_14:
                            # An√°lise das regras faltantes
                            missing_rules = {}
                            for chrom in solutions_14[:100]:  # Pega 100 amostras
                                missing = get_missing_rules(chrom)
                                if missing:
                                    rule_num = missing[0]
                                    missing_rules[rule_num] = (
                                        missing_rules.get(rule_num, 0) + 1
                                    )

                            unique_configs = set(
                                str(chrom) for chrom in solutions_14[:100]
                            )
                            print(
                                f"   üß¨ Configura√ß√µes √∫nicas (14/15): {len(unique_configs)}"
                            )
                            print(f"   üé≤ Regras faltantes: {missing_rules}")

                            if len(unique_configs) < 10:
                                print(
                                    f"   ‚ö†Ô∏è  PROBLEMA: Muito pouca diversidade nas solu√ß√µes 14/15!"
                                )
                                print(
                                    f"   üîÑ Popula√ß√£o convergiu para poucas configura√ß√µes similares"
                                )

                                # AN√ÅLISE CR√çTICA: Por que n√£o consegue sair da configura√ß√£o atual?
                                print(f"\nüö® AN√ÅLISE CR√çTICA - CONFIGURA√á√ÉO TRAVADA:")
                                best_14 = max(solutions_14, key=fitness)
                                print_chromosome_visual(best_14)

                                # Testa FOR√áA BRUTA: o que acontece se quebrarmos TODAS as outras regras?
                                print(f"üî¨ TESTE FOR√áA BRUTA - QUEBRAR OUTRAS REGRAS:")
                                test_candidate = [list(casa) for casa in best_14]

                                # FOR√áA Verde-Branca sequencial nas 4 posi√ß√µes poss√≠veis
                                for verde_pos, branca_pos in [
                                    (0, 1),
                                    (1, 2),
                                    (2, 3),
                                    (3, 4),
                                ]:
                                    # Cria teste focado
                                    test_copy = [list(casa) for casa in test_candidate]

                                    # FOR√áA cores nas posi√ß√µes
                                    cores_originais = [casa[0] for casa in test_copy]
                                    test_copy[verde_pos][0] = "Verde"
                                    test_copy[branca_pos][0] = "Branca"

                                    # Redistribui outras cores
                                    outras_cores = [
                                        c
                                        for c in ["Amarela", "Azul", "Vermelha"]
                                        if (verde_pos != 0 or c != "Verde")
                                        and (branca_pos != 4 or c != "Branca")
                                    ]
                                    outras_posicoes = [
                                        i
                                        for i in range(5)
                                        if i != verde_pos and i != branca_pos
                                    ]

                                    for i, pos in enumerate(
                                        outras_posicoes[: len(outras_cores)]
                                    ):
                                        if i < len(outras_cores):
                                            test_copy[pos][0] = outras_cores[i]

                                    test_fitness = fitness(
                                        [tuple(casa) for casa in test_copy]
                                    )
                                    print(
                                        f"      Verde:{verde_pos+1}->Branca:{branca_pos+1} = Fitness {test_fitness}/15"
                                    )

                                    if test_fitness == 15:
                                        print(
                                            f"   üéâ SOLU√á√ÉO ENCONTRADA! Aplicando configura√ß√£o..."
                                        )
                                        return [tuple(casa) for casa in test_copy]

                        # Executa an√°lise de estagna√ß√£o se necess√°rio
                        is_stagnated = analyze_population_stagnation(POP[:100], fitness)

                        if is_stagnated:
                            print(f"   üö® POPULA√á√ÉO ESTAGNADA DETECTADA!")
                            print(f"   üí• Ativando EXPLOS√ÉO DE DIVERSIDADE")
                            print(f"   üìä Popula√ß√£o atual: {len(POP)} indiv√≠duos")
                            print(
                                f"   üéØ Fitness preso: {best_fitness}/15 (Regra {missing_rule_num})"
                            )

                            # FOR√áA EXPLOS√ÉO DE DIVERSIDADE
                            print(f"\nüî• FASE 1: EXPLOS√ÉO GERAL")
                            POP = diversity_explosion(best_chrom, len(POP), fitness)

                            # FOR√áA VARIA√á√ïES ESPEC√çFICAS DA REGRA PROBLEM√ÅTICA
                            print(f"\nüî• FASE 2: VARIA√á√ïES ESPEC√çFICAS")
                            specific_variations = force_rule_specific_variations(
                                best_chrom, missing_rule_num, 200
                            )
                            POP.extend(specific_variations)

                            print(f"\nüî• FASE 3: RECOMPUTA√á√ÉO")
                            print(
                                f"   üßÆ Calculando fitness para {len(POP)} indiv√≠duos..."
                            )

                            # Recomputa fitness para nova popula√ß√£o
                            fitness_values = [fitness(chrom) for chrom in POP]
                            best_fitness = max(fitness_values)
                            best_chrom = POP[fitness_values.index(best_fitness)]

                            # Nova an√°lise
                            new_dist = {}
                            for f in fitness_values:
                                new_dist[f] = new_dist.get(f, 0) + 1

                            print(f"   üìä Nova distribui√ß√£o:")
                            for f in sorted(new_dist.keys(), reverse=True):
                                if f >= 13:
                                    count = new_dist[f]
                                    percentage = (count / len(POP)) * 100
                                    print(
                                        f"      {f:2d}/15: {count:4d} ({percentage:4.1f}%)"
                                    )

                            print(f"   üèÜ Novo melhor fitness: {best_fitness}/15")

                            # Reset contadores se houve explos√£o
                            if missing_rule_num:
                                if missing_rule_num == 5:
                                    self.generations_at_14 = 0
                                    self.generations_without_improvement = 0
                                    print(f"   üîÑ Contadores resetados")

                            print(f"   ‚úÖ Explos√£o conclu√≠da! Continuando evolu√ß√£o...")

                    # DEBUG DE MUTA√á√ÉO E CROSSOVER
                    if generation % 30 == 0:
                        print(f"\nüß¨ DEBUG OPERA√á√ïES GEN√âTICAS:")
                        print(
                            f"   üé≤ Taxa de muta√ß√£o atual: {self.mutation_rate*100:.1f}%"
                        )
                        print(
                            f"   üíû Taxa de crossover: {self.crossover_rate*100:.1f}%"
                        )
                        print(f"   üë• Tamanho da popula√ß√£o: {len(POP)}")
                        print(
                            f"   üèÜ Elite sobrevivente: {int(len(POP) * SURVIVAL_RATE)}"
                        )
                        print(f"   üÜï Imigrantes: {int(len(POP) * IMMIGRATION_RATE)}")

                        # Teste de efetividade das opera√ß√µes
                        test_chrom = best_chrom
                        original_fitness = fitness(test_chrom)

                        # Testa muta√ß√£o
                        mutated = smart_mutate(
                            test_chrom, self.mutation_rate, original_fitness
                        )
                        mutated_fitness = fitness(mutated)

                        # Testa muta√ß√£o dirigida
                        directed = directed_mutate(test_chrom, [missing_rule_num])
                        directed_fitness = fitness(directed)

                        print(
                            f"   üß™ Teste muta√ß√£o: {original_fitness} ‚Üí {mutated_fitness}"
                        )
                        print(
                            f"   üéØ Teste dirigida: {original_fitness} ‚Üí {directed_fitness}"
                        )

                        if (
                            mutated_fitness == original_fitness
                            and directed_fitness == original_fitness
                        ):
                            print(
                                f"   ‚ö†Ô∏è  PROBLEMA: Muta√ß√µes n√£o est√£o alterando fitness!"
                            )

                    # Estrat√©gias escalantes baseadas no tempo preso
                    if self.generations_at_14 > 100:  # Muito preso
                        # FOR√áA BRUTA TOTAL - tenta todas as combina√ß√µes da regra faltante
                        print(
                            f"   {generation:7d} | {best_fitness:2d}/15   | {len(POP):6d} | {diversity_percent:3.0f}% | {elapsed:6.1f}s | üí• FOR√áA BRUTA TOTAL R{missing_rule_num}"
                        )

                        # Substitui parte da popula√ß√£o com vers√µes especializadas
                        specialized_pop = []
                        for _ in range(50):
                            candidate = best_chrom
                            # Faz 20 muta√ß√µes focadas
                            for _ in range(20):
                                candidate = smart_mutate(candidate, 0.8, 14)
                            specialized_pop.append(candidate)

                        survivors[: len(specialized_pop)] = specialized_pop

                    elif self.generations_at_14 > 50:  # Preso moderadamente
                        # Reparo intensivo + muta√ß√£o dirigida
                        print(
                            f"   {generation:7d} | {best_fitness:2d}/15   | {len(POP):6d} | {diversity_percent:3.0f}% | {elapsed:6.1f}s | üîß REPARO INTENSIVO R{missing_rule_num}"
                        )

                        repaired_pop = []
                        for chrom in POP[:30]:
                            if fitness(chrom) == 14:
                                best_repair = chrom
                                best_fit = 14

                                # 30 tentativas de reparo
                                for _ in range(30):
                                    candidate = smart_mutate(chrom, 0.6, 14)
                                    candidate = directed_mutate(
                                        candidate, [missing_rule_num]
                                    )
                                    cand_fit = fitness(candidate)

                                    if cand_fit > best_fit:
                                        best_repair = candidate
                                        best_fit = cand_fit

                                    if best_fit == 15:
                                        break

                                repaired_pop.append(best_repair)

                        if repaired_pop:
                            survivors[: len(repaired_pop)] = repaired_pop

                    elif self.generations_at_14 > 20:  # In√≠cio do problema
                        print(
                            f"   {generation:7d} | {best_fitness:2d}/15   | {len(POP):6d} | {diversity_percent:3.0f}% | {elapsed:6.1f}s | üéØ FOCO DIRIGIDO R{missing_rule_num}"
                        )

            # Aplicar busca local na elite de alto fitness
            if best_fitness >= 13:
                elite_for_local = POP[: min(5, len(POP))]
                improved_elite = []
                for chrom in elite_for_local:
                    if fitness(chrom) >= 13:
                        improved = local_search(chrom, fitness, 15)
                        improved_elite.append(improved)
                    else:
                        improved_elite.append(chrom)
                survivors[: len(improved_elite)] = improved_elite

            # Reprodu√ß√£o com m√∫ltiplas estrat√©gias
            offspring = []
            target_offspring = (
                len(POP) - num_survivors - int(len(POP) * IMMIGRATION_RATE)
            )

            # Offspring de elite (20%)
            if best_fitness >= 13:
                elite_offspring_count = int(target_offspring * 0.2)
                elite_offspring = create_elite_offspring(
                    POP[:20], fitness_values[:20], fitness
                )[:elite_offspring_count]
                offspring.extend(elite_offspring)

            # Offspring normal
            while len(offspring) < target_offspring:
                # Sele√ß√£o adaptativa
                if best_fitness >= 14:
                    # Torneio pequeno e agressivo
                    p1 = tournament_selection(POP[:10], fitness_values[:10], 3)
                    p2 = tournament_selection(POP[:10], fitness_values[:10], 3)
                elif best_fitness >= 13:
                    # Torneio moderado
                    p1 = tournament_selection(POP[:50], fitness_values[:50], 5)
                    p2 = tournament_selection(POP[:50], fitness_values[:50], 5)
                else:
                    # Sele√ß√£o h√≠brida normal
                    p1 = hybrid_selection(POP[:200], fitness_values[:200])
                    p2 = hybrid_selection(POP[:200], fitness_values[:200])

                # Crossover avan√ßado
                if best_fitness >= 13:
                    c1, c2 = advanced_crossover(p1, p2, self.crossover_rate)
                else:
                    c1, c2 = crossover(p1, p2, self.crossover_rate)

                # Muta√ß√£o inteligente
                missing_rules_1 = get_missing_rules(c1)
                missing_rules_2 = get_missing_rules(c2)

                c1 = smart_mutate(c1, self.mutation_rate, fitness(c1))
                c2 = smart_mutate(c2, self.mutation_rate, fitness(c2))

                # Muta√ß√£o dirigida para alta fitness
                if best_fitness >= 12:
                    c1 = directed_mutate(c1, missing_rules_1)
                    c2 = directed_mutate(c2, missing_rules_2)

                offspring.extend([c1, c2])

            # Imigra√ß√£o especializada
            num_immigrants = int(len(POP) * IMMIGRATION_RATE)
            immigrants = self.create_specialized_population(num_immigrants)

            # Nova gera√ß√£o
            POP = survivors + offspring[:target_offspring] + immigrants

            # Manter tamanho da popula√ß√£o controlado
            if len(POP) > self.population_size:
                POP = POP[: self.population_size]

        # APRESENTA√á√ÉO FINAL DA SOLU√á√ÉO
        print("=" * 80)
        print("                      SOLU√á√ÉO FINAL DETALHADA")
        print("=" * 80)

        show_solution(best_ever_chromosome)

        # An√°lise detalhada
        report = detailed_fitness_report(best_ever_chromosome)
        partial_scores = partial_fitness_scores(best_ever_chromosome)

        print(f"\nüìä AN√ÅLISE DETALHADA:")
        print(f"   ‚úÖ Regras satisfeitas: {report['satisfied']}")
        if report["missing"]:
            print(f"   ‚ùå Regras faltantes: {report['missing']}")
        print(f"   üìà Pontua√ß√£o por categoria:")
        for category, score in partial_scores.items():
            print(f"      {category.capitalize()}: {score}")

        # Resposta do desafio
        for idx, casa in enumerate(best_ever_chromosome, 1):
            if casa[4] == "Peixes":
                print(
                    f"\nüêü RESPOSTA DO DESAFIO: O {casa[1]} tem os Peixes! (Casa {idx})"
                )
                break

        # Estat√≠sticas finais
        final_time = time.time() - start_time
        print(f"\nüìä ESTAT√çSTICAS FINAIS:")
        print(f"   üéØ Fitness final: {best_ever_fitness}/15")
        print(f"   üß¨ Total de gera√ß√µes: {generation:,}")
        print(f"   ‚è±Ô∏è  Tempo total: {final_time:.1f} segundos")
        print(f"   üë• Popula√ß√£o final: {len(POP):,} indiv√≠duos")
        if time_at_14:
            print(f"   üöÄ Tempo para chegar em 14/15: {time_at_14:.1f}s")
            print(f"   ‚ö° Tempo de 14‚Üí15: {final_time - time_at_14:.1f}s")
        print(f"   üìà Taxa de diversidade final: {diversity_percent:.1f}%")

        print(f"\n‚úÖ ALGORITMO GEN√âTICO OTIMIZADO CONCLU√çDO!")

        return best_ever_chromosome, best_ever_fitness


def main():
    """Fun√ß√£o principal"""
    ga = AdvancedGeneticAlgorithm()
    solution, fitness_score = ga.run()

    if fitness_score == 15:
        print("\nüéä PARAB√âNS! Solu√ß√£o perfeita encontrada!")
    else:
        print(f"\n‚ö†Ô∏è Melhor solu√ß√£o encontrada: {fitness_score}/15")


if __name__ == "__main__":
    main()
